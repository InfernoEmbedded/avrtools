--- gcc/config/avr/avr.c.orig	2011-04-02 10:46:29 +1100
+++ gcc/config/avr/avr.c	2011-04-02 10:48:12 +1100
@@ -112,6 +112,12 @@
 static void avr_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,
 				      const_tree, bool);
 static void avr_help (void);
+static bool avr_scalar_mode_supported_p (enum machine_mode);
+static bool avr_fixed_point_supported_p (void);
+void avr_target_help (void);
+static void avr_option_override (void);
+static void avr_conditional_register_usage (void);
+
 
 /* Allocate registers from r25 to r8 for parameters for function calls.  */
 #define FIRST_CUM_REG 26
@@ -229,6 +235,9 @@
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE avr_can_eliminate
 
+#undef TARGET_CONDITIONAL_REGISTER_USAGE
+#define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage
+
 #undef TARGET_CLASS_LIKELY_SPILLED_P
 #define TARGET_CLASS_LIKELY_SPILLED_P avr_class_likely_spilled_p
 
@@ -242,7 +251,7 @@
 #define TARGET_CANNOT_MODIFY_JUMPS_P avr_cannot_modify_jumps_p
 
 #undef TARGET_HELP
-#define TARGET_HELP avr_help
+#define TARGET_HELP avr_target_help
 
 #undef TARGET_SCALAR_MODE_SUPPORTED_P
 #define TARGET_SCALAR_MODE_SUPPORTED_P avr_scalar_mode_supported_p
@@ -257,25 +266,25 @@
 #define TARGET_EXPAND_BUILTIN avr_expand_builtin
 
 
- /* Implement TARGET_SCALAR_MODE_SUPPORTED_P.  */
- static bool
- avr_scalar_mode_supported_p (enum machine_mode mode)
- {
+/* Implement TARGET_SCALAR_MODE_SUPPORTED_P.  */
+static bool
+avr_scalar_mode_supported_p (enum machine_mode mode)
+{
     if (ALL_FIXED_POINT_MODE_P (mode))
        return true;
  
    return default_scalar_mode_supported_p (mode);
- }
+}
  
- /* Implement TARGET_FIXED_POINT_SUPPORTED_P.  */
- static bool
- avr_fixed_point_supported_p ()
- {
-    if (AVR_TINY)
-       return false;
+/* Implement TARGET_FIXED_POINT_SUPPORTED_P.  */
+static bool
+avr_fixed_point_supported_p (void)
+{
+  if (AVR_TINY)
+     return false;
  
-   return default_fixed_point_supported_p ();
- }
+  return default_fixed_point_supported_p ();
+}
 
 /* Implement TARGET_HELP.  */
 void
@@ -6254,6 +6263,22 @@
     output_section_asm_op (data);
 }
 
+/* Implement TARGET_CONDITIONAL_REGISTER_USAGE */
+static void
+avr_conditional_register_usage (void)
+{
+  if (AVR_TINY)
+  {
+    int i;
+    for (i = 0;  i <= 17;  i++) {
+      fixed_regs[i] = 1;
+	  call_used_regs[i] = 1;
+	}
+	CLEAR_HARD_REG_SET(reg_class_contents[(int)ADDW_REGS]);
+	CLEAR_HARD_REG_SET(reg_class_contents[(int)NO_LD_REGS]);
+  }
+}
+
 /* Implement TARGET_ASM_INIT_SECTIONS.  */
 
 static void
@@ -7623,7 +7648,7 @@
 {
   rtx pat;
   tree arg0 = CALL_EXPR_ARG (exp, 0);
-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);
   enum machine_mode op0mode = GET_MODE (op0);
   enum machine_mode tmode = insn_data[icode].operand[0].mode;
   enum machine_mode mode0 = insn_data[icode].operand[1].mode;
@@ -7658,8 +7683,8 @@
   rtx pat;
   tree arg0 = CALL_EXPR_ARG (exp, 0);
   tree arg1 = CALL_EXPR_ARG (exp, 1);
-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);
+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);
   enum machine_mode op0mode = GET_MODE (op0);
   enum machine_mode op1mode = GET_MODE (op1);
   enum machine_mode tmode = insn_data[icode].operand[0].mode;
@@ -7715,7 +7740,6 @@
   const struct builtin_description *d;
   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);
-  rtx pat;
   tree arg0;
   rtx op0;
 
@@ -7736,7 +7760,7 @@
     case AVR_BUILTIN_DELAY_CYCLES:
       {
         arg0 = CALL_EXPR_ARG (exp, 0);
-        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);
 
         if (!CONSTANT_P (op0))
           error ("__builtin_avr_delay_cycles expects an integer constant.");
