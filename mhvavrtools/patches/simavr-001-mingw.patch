diff -ur ../download/simavr/Makefile.common simavr/Makefile.common
--- ../download/simavr/Makefile.common	2012-03-11 10:53:04 +1100
+++ simavr/Makefile.common	2012-03-11 10:56:13 +1100
@@ -49,8 +49,16 @@
 AVR_ROOT 	:= /usr/lib/avr
 AVR_INC 	:= ${AVR_ROOT}
 AVR 		:= avr-
+ifeq (${shell uname}, MINGW32_NT-6.1)
+AVR_ROOT    := ${PREFIX}
+AVR_INC     := ${AVR_ROOT}/avr
+AVR         := ${AVR_ROOT}/bin/avr-
+IPATH       += ${PREFIX}/include
+CFLAGS      += -I${PREFIX}/include
+else
 CFLAGS 		+= -fPIC
 endif
+endif
 
 CC 			?= gcc
 AR 			?= ar
@@ -67,6 +75,11 @@
 
 LDFLAGS 	+= -lelf 
 
+ifeq (${shell uname}, MINGW32_NT-6.1)
+LDFLAGS      += -L"/c/Program Files (x86)/Microsoft SDKs/Windows/v7.0a/lib/ws2_32.lib"
+LDFLAGS      += -lws2_32
+endif
+
 ifeq (${shell uname}, Linux)
 # allow the shared library to be found in the build directory
 LFLAGS		+= -Wl,-rpath,${LIBDIR}
@@ -86,6 +99,19 @@
 
 # --mcall-prologues can be used here, but messes up debugging a little
 %.axf: %.c 
+ifeq ($(V),1)
+	part=${<} ; part=$${part/_*}; \
+	${AVR}gcc -Wall -gdwarf-2 -Os -std=gnu99 \
+			-mmcu=$$part \
+			-DF_CPU=8000000 \
+			-fno-inline-small-functions \
+			-ffunction-sections -fdata-sections \
+			-Wl,--relax,--gc-sections \
+			-Wl,--undefined=_mmcu,--section-start=.mmcu=0x910000 \
+			-I../include -I../../include \
+			${^} -o ${@}
+	${AVR}size ${@}|sed '1d'    
+else
 	@echo AVR-CC ${<}
 	@part=${<} ; part=$${part/_*}; \
 	${AVR}gcc -Wall -gdwarf-2 -Os -std=gnu99 \
@@ -98,6 +124,7 @@
 			-I../include -I../../include \
 			${^} -o ${@}
 	@${AVR}size ${@}|sed '1d'
+endif
 
 # this rule has precedence
 ${OBJ}/sim_%.o : cores/sim_%.c
Only in simavr: Makefile.common.orig
diff -ur ../download/simavr/examples/Makefile simavr/examples/Makefile
--- ../download/simavr/examples/Makefile	2012-03-11 10:53:04 +1100
+++ simavr/examples/Makefile	2012-03-11 10:52:48 +1100
@@ -3,6 +3,10 @@
 # remove vhci example on anything but linux
 ifneq (${shell uname}, Linux)
 boards=${subst board_usb,,$(boards_base)}
+# Remove simduino until FileMapping is implemented to work around missing mmap in Win32
+ifeq (${shell uname}, MINGW32_NT-6.1)
+boards=${subst board_usb,,${subst board_simduino,,$(boards_base)}}
+endif
 else
 boards=$(boards_base)
 endif
diff -ur ../download/simavr/examples/board_hd77480/Makefile simavr/examples/board_hd77480/Makefile
--- ../download/simavr/examples/board_hd77480/Makefile	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_hd77480/Makefile	2012-03-11 10:52:48 +1100
@@ -32,10 +32,14 @@
 VPATH += ../parts
 
 LDFLAGS += -lpthread
-ifneq (${shell uname}, Darwin)
-LDFLAGS += -lGL -lglut
-else
+ifeq (${shell uname}, Darwin)
 LDFLAGS += -framework GLUT -framework OpenGL 
+else
+ifeq (${shell uname}, MINGW32_NT-6.1)
+LDFLAGS += -mwindows ${PREFIX}/lib/glut32.lib -lopengl32 -lglut32
+else
+LDFLAGS += -lGL -lglut
+endif
 endif
 
 all: obj atmega48_charlcd.axf ${target} 
diff -ur ../download/simavr/examples/board_hd77480/charlcd.c simavr/examples/board_hd77480/charlcd.c
--- ../download/simavr/examples/board_hd77480/charlcd.c	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_hd77480/charlcd.c	2012-03-11 10:52:48 +1100
@@ -33,6 +33,9 @@
 #if __APPLE__
 #include <GLUT/glut.h>
 #else
+#ifdef __MINGW32__
+#include <windows.h>
+#endif
 #include <GL/glut.h>
 #endif
 #include <pthread.h>
diff -ur ../download/simavr/examples/board_ledramp/Makefile simavr/examples/board_ledramp/Makefile
--- ../download/simavr/examples/board_ledramp/Makefile	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_ledramp/Makefile	2012-03-11 10:52:48 +1100
@@ -32,10 +32,14 @@
 VPATH += ../parts
 
 LDFLAGS += -lpthread
-ifneq (${shell uname}, Darwin)
-LDFLAGS += -lGL -lglut
-else
+ifeq (${shell uname}, Darwin)
 LDFLAGS += -framework GLUT -framework OpenGL 
+else
+ifeq (${shell uname}, MINGW32_NT-6.1)
+LDFLAGS += -mwindows ${PREFIX}/lib/glut32.lib -lopengl32 -lglut32
+else
+LDFLAGS += -lGL -lglut
+endif
 endif
 
 all: obj ${firmware} ${target}
diff -ur ../download/simavr/examples/board_ledramp/ledramp.c simavr/examples/board_ledramp/ledramp.c
--- ../download/simavr/examples/board_ledramp/ledramp.c	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_ledramp/ledramp.c	2012-03-11 10:52:48 +1100
@@ -1,6 +1,6 @@
 /*
 	ledramp.c
-	
+
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
  	This file is part of simavr.
@@ -25,6 +25,9 @@
 #if __APPLE__
 #include <GLUT/glut.h>
 #else
+#ifdef __MINGW32__
+#include <windows.h>
+#endif
 #include <GL/glut.h>
 #endif
 #include <pthread.h>
@@ -126,7 +129,7 @@
 static void * avr_run_thread(void * oaram)
 {
 	int b_press = do_button_press;
-	
+
 	while (1) {
 		avr_run(avr);
 		if (do_button_press != b_press) {
@@ -170,7 +173,7 @@
 	for (int i = 0; i < 8; i++)
 		avr_irq_register_notify(
 			avr_io_getirq(avr, AVR_IOCTL_IOPORT_GETIRQ('B'), i),
-			pin_changed_hook, 
+			pin_changed_hook,
 			NULL);
 
 	// even if not setup at startup, activate gdb if crashing
@@ -182,16 +185,16 @@
 
 	/*
 	 *	VCD file initialization
-	 *	
+	 *
 	 *	This will allow you to create a "wave" file and display it in gtkwave
 	 *	Pressing "r" and "s" during the demo will start and stop recording
 	 *	the pin changes
 	 */
 	avr_vcd_init(avr, "gtkwave_output.vcd", &vcd_file, 100000 /* usec */);
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		avr_io_getirq(avr, AVR_IOCTL_IOPORT_GETIRQ('B'), IOPORT_IRQ_PIN_ALL), 8 /* bits */ ,
 		"portb" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		button.irq + IRQ_BUTTON_OUT, 1 /* bits */ ,
 		"button" );
 
diff -ur ../download/simavr/examples/board_simduino/Makefile simavr/examples/board_simduino/Makefile
--- ../download/simavr/examples/board_simduino/Makefile	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_simduino/Makefile	2012-03-11 10:52:48 +1100
@@ -32,12 +32,17 @@
 VPATH += ../parts
 
 LDFLAGS += -lpthread
-ifneq (${shell uname}, Darwin)
-LDFLAGS += -lGL -lglut
-else
+ifeq (${shell uname}, Darwin)
 LDFLAGS += -framework GLUT -framework OpenGL 
+else
+ifeq (${shell uname}, MINGW32_NT-6.1)
+LDFLAGS += -mwindows ${PREFIX}/lib/glut32.lib -lopengl32 -lglut32
+else
+LDFLAGS += -lGL -lglut
+endif
 endif
 
+
 all: obj ${firmware} ${target}
 
 include ${simavr}/Makefile.common
Only in simavr/examples/board_simduino: atmega328p_dummy_blinky.hex
diff -ur ../download/simavr/examples/board_simduino/simduino.c simavr/examples/board_simduino/simduino.c
--- ../download/simavr/examples/board_simduino/simduino.c	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_simduino/simduino.c	2012-03-11 10:52:48 +1100
@@ -19,7 +19,9 @@
 	along with simavr.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifndef __MINGW32__
 #include <sys/mman.h>
+#endif
 #include <unistd.h>
 #include <sys/stat.h>
 #include <fcntl.h>
diff -ur ../download/simavr/examples/board_timer_64led/Makefile simavr/examples/board_timer_64led/Makefile
--- ../download/simavr/examples/board_timer_64led/Makefile	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_timer_64led/Makefile	2012-03-11 10:52:48 +1100
@@ -32,10 +32,14 @@
 VPATH += ../parts
 
 LDFLAGS += -lpthread
-ifneq (${shell uname}, Darwin)
-LDFLAGS += -lGL -lglut
-else
+ifeq (${shell uname}, Darwin)
 LDFLAGS += -framework GLUT -framework OpenGL 
+else
+ifeq (${shell uname}, MINGW32_NT-6.1)
+LDFLAGS += -mwindows ${PREFIX}/lib/glut32.lib -lopengl32 -lglut32
+else
+LDFLAGS += -lGL -lglut
+endif
 endif
 
 all: obj ${firmware} ${target}
diff -ur ../download/simavr/examples/board_timer_64led/timer_64led.c simavr/examples/board_timer_64led/timer_64led.c
--- ../download/simavr/examples/board_timer_64led/timer_64led.c	2012-03-11 10:53:03 +1100
+++ simavr/examples/board_timer_64led/timer_64led.c	2012-03-11 10:52:48 +1100
@@ -1,6 +1,6 @@
 /*
 	timer_64led.c
-	
+
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
  	This file is part of simavr.
@@ -25,6 +25,9 @@
 #if __APPLE__
 #include <GLUT/glut.h>
 #else
+#ifdef __MINGW32__
+#include <windows.h>
+#endif
 #include <GL/glut.h>
 #endif
 #include <pthread.h>
@@ -92,13 +95,13 @@
 		color_on = color_off;
 
 	glTranslatef(pixsize / 2.25f, pixsize / 1.8f, 0);
-	
+
     glBegin(GL_QUADS);
-	
+
 	for (int di = 0; di < 4; di++) {
 		uint8_t digit = display_bits >> (di * 8);
-		
-		for (int i = 0; i < 8; i++) {	
+
+		for (int i = 0; i < 8; i++) {
 			glColor3f(0,0, digit & (1 << i) ? color_on : color_off);
 			float dx = ((di * 5.5)) * pixsize, dy = 0*pixsize;
 			switch (i) {
@@ -127,8 +130,8 @@
 							dx -= 5.50 * pixsize;
 							break;
 					}
-							
-					glVertex2f(dx + size, dy + size); glVertex2f(dx, dy + size); glVertex2f(dx, dy); glVertex2f(dx + size, dy);					
+
+					glVertex2f(dx + size, dy + size); glVertex2f(dx, dy + size); glVertex2f(dx, dy); glVertex2f(dx + size, dy);
 					break;
 				default:
 					if (i == 1 || i == 2)
@@ -136,7 +139,7 @@
 					if (i == 4 || i == 2)
 						dy += 4.0f * pixsize;
 					else
-						dy += 1.0f * pixsize;					
+						dy += 1.0f * pixsize;
 					glVertex2f(dx + size, dy + size); glVertex2f(dx, dy + size); glVertex2f(dx, dy); glVertex2f(dx + size, dy);
 					dy += 1.0f * pixsize;
 					glVertex2f(dx + size, dy + size); glVertex2f(dx, dy + size); glVertex2f(dx, dy); glVertex2f(dx + size, dy);
@@ -191,7 +194,7 @@
 static void * avr_run_thread(void * ignore)
 {
 	int b_press[3] = {0};
-	
+
 	while (1) {
 		avr_run(avr);
 
@@ -231,7 +234,7 @@
 	// initialize our 'peripherals'
 	//
 	hc595_init(avr, &shifter);
-	
+
 	button_init(avr, &button[B_START], "button.start");
 	avr_connect_irq(
 		button[B_START].irq + IRQ_BUTTON_OUT,
@@ -256,11 +259,11 @@
 	avr_irq_t * i_pwm = avr_io_getirq(avr, AVR_IOCTL_TIMER_GETIRQ('0'), TIMER_IRQ_OUT_PWM0);
 	avr_irq_register_notify(
 		i_pwm,
-		pwm_changed_hook, 
-		NULL);	
+		pwm_changed_hook,
+		NULL);
 	avr_irq_register_notify(
 		shifter.irq + IRQ_HC595_OUT,
-		hc595_changed_hook, 
+		hc595_changed_hook,
 		NULL);
 
 	// even if not setup at startup, activate gdb if crashing
@@ -272,43 +275,43 @@
 
 	/*
 	 *	VCD file initialization
-	 *	
+	 *
 	 *	This will allow you to create a "wave" file and display it in gtkwave
 	 *	Pressing "r" and "s" during the demo will start and stop recording
 	 *	the pin changes
 	 */
 	avr_vcd_init(avr, "gtkwave_output.vcd", &vcd_file, 10000 /* usec */);
 
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		avr_get_interrupt_irq(avr, 7), 1 /* bit */ ,
 		"TIMER2_COMPA" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		avr_get_interrupt_irq(avr, 17), 1 /* bit */ ,
 		"SPI_INT" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		i_mosi, 8 /* bits */ ,
 		"MOSI" );
 
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		i_reset, 1 /* bit */ ,
 		"595_RESET" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		i_latch, 1 /* bit */ ,
 		"595_LATCH" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		button[B_START].irq + IRQ_BUTTON_OUT, 1 /* bits */ ,
 		"start" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		button[B_STOP].irq + IRQ_BUTTON_OUT, 1 /* bits */ ,
 		"stop" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		button[B_RESET].irq + IRQ_BUTTON_OUT, 1 /* bits */ ,
 		"reset" );
 
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		shifter.irq + IRQ_HC595_OUT, 32 /* bits */ ,
 		"HC595" );
-	avr_vcd_add_signal(&vcd_file, 
+	avr_vcd_add_signal(&vcd_file,
 		i_pwm, 8 /* bits */ ,
 		"PWM" );
 
@@ -336,7 +339,7 @@
 
 
 	int w = 22, h = 8;
-	
+
 	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
 	glutInitWindowSize(w * pixsize, h * pixsize);		/* width=400pixels height=500pixels */
 	window = glutCreateWindow("Press 0, 1, 2 or q");	/* create window */
diff -ur ../download/simavr/examples/parts/hd44780_glut.c simavr/examples/parts/hd44780_glut.c
--- ../download/simavr/examples/parts/hd44780_glut.c	2012-03-11 10:53:04 +1100
+++ simavr/examples/parts/hd44780_glut.c	2012-03-11 10:52:49 +1100
@@ -25,6 +25,9 @@
 #if __APPLE__
 #include <GLUT/glut.h>
 #else
+#ifdef __MINGW32__
+#include <windows.h>
+#endif
 #include <GL/glut.h>
 #endif
 
diff -ur ../download/simavr/examples/parts/uart_udp.c simavr/examples/parts/uart_udp.c
--- ../download/simavr/examples/parts/uart_udp.c	2012-03-11 10:53:04 +1100
+++ simavr/examples/parts/uart_udp.c	2012-03-11 10:52:49 +1100
@@ -19,10 +19,15 @@
 	along with simavr.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef __MINGW32__
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#else
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
+#endif
 #include <sys/time.h>
 #include <pthread.h>
 #include <string.h>
@@ -97,7 +102,7 @@
 			continue;
 
 		if (FD_ISSET(p->s, &read_set)) {
-			uint8_t buffer[512];
+			char buffer[512];
 
 			socklen_t len = sizeof(p->peer);
 			ssize_t r = recvfrom(p->s, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&p->peer, &len);
@@ -105,16 +110,21 @@
 		//	hdump("udp recv", buffer, r);
 
 			// write them in fifo
-			uint8_t * src = buffer;
+			char * src = buffer;
 			while (r-- && !uart_udp_fifo_isfull(&p->out))
 				uart_udp_fifo_write(&p->out, *src++);
-			if (r > 0)
+			if (r > 0) {
+#if __MINGW32__
+				printf("UDP dropped %I64u bytes\n", (unsigned long long)r);
+#else
 				printf("UDP dropped %zu bytes\n", r);
+#endif
+			}
 		}
 		if (FD_ISSET(p->s, &write_set)) {
-			uint8_t buffer[512];
+			char buffer[512];
 			// write them in fifo
-			uint8_t * dst = buffer;
+			char * dst = buffer;
 			while (!uart_udp_fifo_isempty(&p->in) && dst < (buffer+sizeof(buffer)))
 				*dst++ = uart_udp_fifo_read(&p->in);
 			socklen_t len = dst - buffer;
diff -ur ../download/simavr/examples/parts/uart_udp.h simavr/examples/parts/uart_udp.h
--- ../download/simavr/examples/parts/uart_udp.h	2012-03-11 10:53:04 +1100
+++ simavr/examples/parts/uart_udp.h	2012-03-11 10:52:49 +1100
@@ -23,7 +23,12 @@
 #ifndef __UART_UDP_H___
 #define __UART_UDP_H___
 
+#ifdef __MINGW32__
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#else
 #include <netinet/in.h>
+#endif
 #include "sim_irq.h"
 #include "fifo_declare.h"
 
diff -ur ../download/simavr/simavr/Makefile simavr/simavr/Makefile
--- ../download/simavr/simavr/Makefile	2012-03-11 10:53:05 +1100
+++ simavr/simavr/Makefile	2012-03-11 10:52:50 +1100
@@ -43,7 +43,10 @@
 IPATH	+= .
 IPATH	+= ../../shared
 IPATH	+= ../include
-    
+ifeq (${shell uname}, MINGW32_NT-6.1)
+IPATH       += ${PREFIX}/include
+endif
+
 #
 # Static library
 #
@@ -105,7 +108,7 @@
 		file=$$core; global=$${core/cores\/sim_}; global=$${global/.c}; \
 		upper=$$(echo $$global|tr '[a-z]' '[A-Z]'); \
 		if $(CC) -E $(CFLAGS) -I$(AVR_INC)/include $$file \
-			>/dev/null 2>&1 ; then \
+			>/dev/null; then \
 			conf+="#define CONFIG_$$upper 1\n"; \
 			obj=$${file/.c/.o} ; obj=$${obj/cores\/}; \
 			printf "\$${OBJ}/libsimavr.a: \$${OBJ}/$$obj\n">>${OBJ}/cores.deps ; \
diff -ur ../download/simavr/simavr/cores/sim_mega128.c simavr/simavr/cores/sim_mega128.c
--- ../download/simavr/simavr/cores/sim_mega128.c	2012-03-11 10:53:04 +1100
+++ simavr/simavr/cores/sim_mega128.c	2012-03-11 10:52:49 +1100
@@ -218,7 +218,7 @@
 		.wgm = { AVR_IO_REGBIT(TCCR0, WGM00), AVR_IO_REGBIT(TCCR0, WGM01) },
 		.wgm_op = {
 			[0] = AVR_TIMER_WGM_NORMAL8(),
-			// PHASE CORRECT 
+			// PHASE CORRECT
 			[2] = AVR_TIMER_WGM_CTC(),
 			[3] = AVR_TIMER_WGM_FASTPWM8(),
 		},
@@ -228,7 +228,7 @@
 
 		// asynchronous timer source bit.. if set, use 32khz frequency
 		.as2 = AVR_IO_REGBIT(ASSR, AS0),
-		
+
 		.r_tcnt = TCNT0,
 
 		.overflow = {
@@ -330,7 +330,7 @@
 		.wgm = { AVR_IO_REGBIT(TCCR2, WGM20), AVR_IO_REGBIT(TCCR2, WGM21) },
 		.wgm_op = {
 			[0] = AVR_TIMER_WGM_NORMAL8(),
-			// TODO 1 pwm phase correct 
+			// TODO 1 pwm phase correct
 			[2] = AVR_TIMER_WGM_CTC(),
 			[3] = AVR_TIMER_WGM_FASTPWM8(),
 		},
@@ -338,7 +338,7 @@
 		.cs_div = { 0, 0, 3 /* 8 */, 6 /* 64 */, 8 /* 256 */, 10 /* 1024 */ /* TODO external clock */ },
 
 		.r_tcnt = TCNT2,
-		
+
 		.overflow = {
 			.enable = AVR_IO_REGBIT(TIMSK, TOIE2),
 			.raised = AVR_IO_REGBIT(TIFR, TOV2),
@@ -451,7 +451,7 @@
 			.vector = SPI_STC_vect,
 		},
 	},
-	
+
 	.twi = {
 
 		.r_twcr = TWCR,
@@ -494,7 +494,7 @@
 	struct mcu_t * mcu = (struct mcu_t*)avr;
 
 	printf("%s init\n", avr->mmcu);
-	
+
 	avr_eeprom_init(avr, &mcu->eeprom);
 	avr_flash_init(avr, &mcu->selfprog);
 	avr_extint_init(avr, &mcu->extint);
diff -ur ../download/simavr/simavr/cores/sim_tiny13.c simavr/simavr/cores/sim_tiny13.c
--- ../download/simavr/simavr/cores/sim_tiny13.c	2012-03-11 10:53:05 +1100
+++ simavr/simavr/cores/sim_tiny13.c	2012-03-11 10:52:49 +1100
@@ -2,9 +2,9 @@
 	sim_tiny13.c
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
-	                     Jon Escombe <lists@dresco.co.uk>
+						 Jon Escombe <lists@dresco.co.uk>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -20,7 +20,7 @@
 	along with simavr.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include </usr/include/stdio.h>
+#include <stdio.h>
 #include "sim_avr.h"
 #include "sim_core_declare.h"
 #include "avr_eeprom.h"
diff -ur ../download/simavr/simavr/cores/sim_tiny2313.c simavr/simavr/cores/sim_tiny2313.c
--- ../download/simavr/simavr/cores/sim_tiny2313.c	2012-03-11 10:53:05 +1100
+++ simavr/simavr/cores/sim_tiny2313.c	2012-03-11 10:52:49 +1100
@@ -3,7 +3,7 @@
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -19,7 +19,7 @@
 	along with simavr.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include </usr/include/stdio.h>
+#include <stdio.h>
 #include "sim_core_declare.h"
 #include "avr_eeprom.h"
 #include "avr_watchdog.h"
Only in simavr/simavr: obj-
diff -ur ../download/simavr/simavr/sim/avr_watchdog.h simavr/simavr/sim/avr_watchdog.h
--- ../download/simavr/simavr/sim/avr_watchdog.h	2012-03-11 10:53:05 +1100
+++ simavr/simavr/sim/avr_watchdog.h	2012-03-11 10:52:50 +1100
@@ -68,7 +68,7 @@
 /* no WDP3, WDIE, WDIF in atmega128 */
 #define AVR_WATCHDOG_DECLARE_128(_WDSR, _vec) \
 	.watchdog = {\
-		.wdrf = AVR_IO_REGBIT(MCUSR, WDRF),\
+		.wdrf = AVR_IO_REGBIT(MCUCSR, WDRF),\
 		.wdce = AVR_IO_REGBIT(_WDSR, WDCE),\
 		.wde = AVR_IO_REGBIT(_WDSR, WDE),\
 		.wdp = { AVR_IO_REGBIT(_WDSR, WDP0),AVR_IO_REGBIT(_WDSR, WDP1),\
diff -ur ../download/simavr/simavr/sim/run_avr.c simavr/simavr/sim/run_avr.c
--- ../download/simavr/simavr/sim/run_avr.c	2012-03-11 10:53:05 +1100
+++ simavr/simavr/sim/run_avr.c	2012-03-11 10:52:50 +1100
@@ -3,7 +3,7 @@
 
 	Copyright 2008, 2010 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -36,10 +36,10 @@
 {
 	printf("usage: %s [-t] [-g] [-m <device>] [-f <frequency>] firmware\n", app);
 	printf("       -t: run full scale decoder trace\n"
-		   "       -g: listen for gdb connection on port 1234\n"
-		   "       -ff: Loads next .hex file as flash\n"
-		   "       -ee: Loads next .hex file as eeprom\n"
-		   "   Supported AVR cores:\n");
+		"       -g: listen for gdb connection on port 1234\n"
+		"       -ff: Loads next .hex file as flash\n"
+		"       -ee: Loads next .hex file as eeprom\n"
+		"   Supported AVR cores:\n");
 	for (int i = 0; avr_kind[i]; i++) {
 		printf("       ");
 		for (int ti = 0; ti < 4 && avr_kind[i]->names[ti]; ti++)
@@ -98,7 +98,7 @@
 		} else if (!strcmp(argv[pi], "-ee")) {
 			loadBase = AVR_SEGMENT_OFFSET_EEPROM;
 		} else if (!strcmp(argv[pi], "-ff")) {
-			loadBase = AVR_SEGMENT_OFFSET_FLASH;			
+			loadBase = AVR_SEGMENT_OFFSET_FLASH;
 		} else if (argv[pi][0] != '-') {
 			char * filename = argv[pi];
 			char * suffix = strrchr(filename, '.');
@@ -110,7 +110,7 @@
 				struct ihex_chunk_t chunk[4];
 				int cnt = read_ihex_chunks(filename, chunk, 4);
 				if (cnt <= 0) {
-					fprintf(stderr, "%s: Unable to load IHEX file %s\n", 
+					fprintf(stderr, "%s: Unable to load IHEX file %s\n",
 						argv[0], argv[pi]);
 					exit(1);
 				}
@@ -171,6 +171,6 @@
 		if ( state == cpu_Done || state == cpu_Crashed)
 			break;
 	}
-	
+
 	avr_terminate(avr);
 }
diff -ur ../download/simavr/simavr/sim/sim_avr.c simavr/simavr/sim/sim_avr.c
--- ../download/simavr/simavr/sim/sim_avr.c	2012-03-11 10:53:05 +1100
+++ simavr/simavr/sim/sim_avr.c	2012-03-11 10:52:50 +1100
@@ -3,7 +3,7 @@
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -22,7 +22,9 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#ifndef __MINGW32__
 #include <unistd.h>
+#endif
 #include "sim_avr.h"
 #include "sim_core.h"
 #include "sim_time.h"
@@ -56,7 +58,7 @@
 	avr->sleep = avr_callback_sleep_raw;
 	avr->state = cpu_Running;
 	avr->log = 1;
-	avr_reset(avr);	
+	avr_reset(avr);
 	return 0;
 }
 
@@ -102,7 +104,7 @@
 		// enable gdb server, and wait
 		if (!avr->gdb)
 			avr_gdb_init(avr);
-	} 
+	}
 	if (!avr->gdb)
 		avr->state = cpu_Crashed;
 }
@@ -191,7 +193,7 @@
 	int step = avr->state == cpu_Step;
 	if (step)
 		avr->state = cpu_Running;
-	
+
 	uint16_t new_pc = avr->pc;
 
 	if (avr->state == cpu_Running) {
@@ -230,13 +232,34 @@
 	// Interrupt servicing might change the PC too, during 'sleep'
 	if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
 		avr_service_interrupts(avr);
-	
+
 	// if we were stepping, use this state to inform remote gdb
 	if (step)
 		avr->state = cpu_StepDone;
 
 }
 
+#ifdef __MINGW32__
+#include <windows.h>
+/* Borrowed from ScummVM under the GPL
+ * http://sourceforge.net/apps/trac/scummvm/browser/vendor/freesci/glutton/src/win32/usleep.c?rev=38187
+ */
+void usleep (long usec) {
+	LARGE_INTEGER lFrequency;
+	LARGE_INTEGER lEndTime;
+	LARGE_INTEGER lCurTime;
+
+	QueryPerformanceFrequency (&lFrequency);
+	if (lFrequency.QuadPart) {
+		QueryPerformanceCounter (&lEndTime);
+		lEndTime.QuadPart += (LONGLONG) usec * lFrequency.QuadPart / 1000000;
+		do {
+			QueryPerformanceCounter (&lCurTime);
+			Sleep(0);
+		} while (lCurTime.QuadPart < lEndTime.QuadPart);
+	}
+}
+#endif
 void avr_callback_sleep_raw(avr_t * avr, avr_cycle_count_t howLong)
 {
 	uint32_t usec = avr_cycles_to_usec(avr, howLong);
@@ -339,6 +362,6 @@
 
 	avr_t * avr = maker->make();
 	printf("Starting %s - flashend %04x ramend %04x e2end %04x\n", avr->mmcu, avr->flashend, avr->ramend, avr->e2end);
-	return avr;	
+	return avr;
 }
 
diff -ur ../download/simavr/simavr/sim/sim_elf.c simavr/simavr/sim/sim_elf.c
--- ../download/simavr/simavr/sim/sim_elf.c	2012-03-11 10:53:06 +1100
+++ simavr/simavr/sim/sim_elf.c	2012-03-11 10:52:50 +1100
@@ -7,7 +7,7 @@
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -25,9 +25,11 @@
 
 #include <sys/stat.h>
 #include <fcntl.h>
+#ifndef __MINGW32__
 #include <unistd.h>
-#include <stdlib.h>
 #include <stdio.h>
+#endif
+#include <stdlib.h>
 #include <string.h>
 #include <libelf.h>
 #include <gelf.h>
@@ -62,11 +64,11 @@
 		return;
 	avr->vcd = malloc(sizeof(*avr->vcd));
 	memset(avr->vcd, 0, sizeof(*avr->vcd));
-	avr_vcd_init(avr, 
+	avr_vcd_init(avr,
 		firmware->tracename[0] ? firmware->tracename: "gtkwave_trace.vcd",
 		avr->vcd,
 		firmware->traceperiod >= 1000 ? firmware->traceperiod : 1000);
-	
+
 	printf("Creating VCD trace file '%s'\n", avr->vcd->filename);
 	for (int ti = 0; ti < firmware->tracecount; ti++) {
 		if (firmware->trace[ti].mask == 0xff || firmware->trace[ti].mask == 0) {
@@ -91,14 +93,14 @@
 							__FUNCTION__, firmware->trace[ti].addr);
 						break;
 					}
-					
+
 					if (count == 1) {
 						avr_vcd_add_signal(avr->vcd, bit, 1, firmware->trace[ti].name);
 						break;
 					}
 					char comp[128];
 					sprintf(comp, "%s.%d", firmware->trace[ti].name, bi);
-					avr_vcd_add_signal(avr->vcd, bit, 1, firmware->trace[ti].name);					
+					avr_vcd_add_signal(avr->vcd, bit, 1, firmware->trace[ti].name);
 				}
 		}
 	}
@@ -122,7 +124,7 @@
 				break;
 			case AVR_MMCU_TAG_NAME:
 				strcpy(firmware->mmcu, (char*)src);
-				break;		
+				break;
 			case AVR_MMCU_TAG_VCC:
 				firmware->vcc =
 					src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);
@@ -142,7 +144,7 @@
 				printf("AVR_MMCU_TAG_VCD_TRACE %04x:%02x - %s\n", addr, mask, name);
 				firmware->trace[firmware->tracecount].mask = mask;
 				firmware->trace[firmware->tracecount].addr = addr;
-				strncpy(firmware->trace[firmware->tracecount].name, name, 
+				strncpy(firmware->trace[firmware->tracecount].name, name,
 					sizeof(firmware->trace[firmware->tracecount].name));
 				firmware->tracecount++;
 			}	break;
@@ -179,7 +181,7 @@
 		return -1;
 	}
 
-	Elf_Data *data_data = NULL, 
+	Elf_Data *data_data = NULL,
 		*data_text = NULL,
 		*data_ee = NULL;                /* Data Descriptor */
 
@@ -241,8 +243,8 @@
 
 				// print out the value and size
 			//	printf("%08x %08d ", sym.st_value, sym.st_size);
-				if (ELF32_ST_BIND(sym.st_info) == STB_GLOBAL || 
-						ELF32_ST_TYPE(sym.st_info) == STT_FUNC || 
+				if (ELF32_ST_BIND(sym.st_info) == STB_GLOBAL ||
+						ELF32_ST_TYPE(sym.st_info) == STT_FUNC ||
 						ELF32_ST_TYPE(sym.st_info) == STT_OBJECT) {
 					const char * name = elf_strptr(elf, shdr.sh_link, sym.st_name);
 
@@ -280,12 +282,20 @@
 	//	hdump("code", data_text->d_buf, data_text->d_size);
 		memcpy(firmware->flash + offset, data_text->d_buf, data_text->d_size);
 		offset += data_text->d_size;
+#ifdef __MINGW32__
+		printf("Loaded %Iu .text\n", data_text->d_size);
+#else
 		printf("Loaded %zu .text\n", data_text->d_size);
+#endif
 	}
 	if (data_data) {
 	//	hdump("data", data_data->d_buf, data_data->d_size);
 		memcpy(firmware->flash + offset, data_data->d_buf, data_data->d_size);
+#ifdef __MINGW32__
+		printf("Loaded %Iu .data\n", data_data->d_size);
+#else
 		printf("Loaded %zu .data\n", data_data->d_size);
+#endif
 		offset += data_data->d_size;
 		firmware->datasize = data_data->d_size;
 	}
@@ -293,7 +303,11 @@
 	//	hdump("eeprom", data_ee->d_buf, data_ee->d_size);
 		firmware->eeprom = malloc(data_ee->d_size);
 		memcpy(firmware->eeprom, data_ee->d_buf, data_ee->d_size);
+#ifdef __MINGW32__
+		printf("Loaded %Iu .eeprom\n", data_ee->d_size);
+#else
 		printf("Loaded %zu .eeprom\n", data_ee->d_size);
+#endif
 		firmware->eesize = data_ee->d_size;
 	}
 //	hdump("flash", avr->flash, offset);
diff -ur ../download/simavr/simavr/sim/sim_gdb.c simavr/simavr/sim/sim_gdb.c
--- ../download/simavr/simavr/sim/sim_gdb.c	2012-03-11 10:53:06 +1100
+++ simavr/simavr/sim/sim_gdb.c	2012-03-11 10:52:51 +1100
@@ -3,7 +3,7 @@
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -19,17 +19,22 @@
 	along with simavr.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#ifdef __MINGW32__
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#else
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
+#include <poll.h>
+#endif
 #include <sys/time.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
-#include <poll.h>
 #include <pthread.h>
 #include "sim_avr.h"
 #include "sim_hex.h"
@@ -64,7 +69,11 @@
 	}
 	sprintf((char*)dst, "#%02x", check);
 	DBG(printf("%s '%s'\n", __FUNCTION__, reply);)
+#if __MINGW32__
+	send(g->s, (const char *)reply, dst - reply + 3, 0);
+#else
 	send(g->s, reply, dst - reply + 3, 0);
+#endif
 }
 
 static void gdb_send_quick_status(avr_gdb_t * g, uint8_t signal)
@@ -72,7 +81,7 @@
 	char cmd[64];
 
 	sprintf(cmd, "T%02x20:%02x;21:%02x%02x;22:%02x%02x%02x00;",
-		signal ? signal : 5, g->avr->data[R_SREG], 
+		signal ? signal : 5, g->avr->data[R_SREG],
 		g->avr->data[R_SPL], g->avr->data[R_SPH],
 		g->avr->pc & 0xff, (g->avr->pc>>8)&0xff, (g->avr->pc>>16)&0xff);
 	gdb_send_reply(g, cmd);
@@ -145,7 +154,7 @@
 			sprintf(rep, "%02x%02x", g->avr->data[R_SPL], g->avr->data[R_SPH]);
 			break;
 		case 34:
-			sprintf(rep, "%02x%02x%02x00", 
+			sprintf(rep, "%02x%02x%02x00",
 				g->avr->pc & 0xff, (g->avr->pc>>8)&0xff, (g->avr->pc>>16)&0xff);
 			break;
 	}
@@ -167,19 +176,19 @@
 			uint8_t *src = (uint8_t*)rep;
 			for (int i = 0; i < 35; i++)
 				src += gdb_write_register(g, i, src);
-			gdb_send_reply(g, "OK");										
+			gdb_send_reply(g, "OK");
 		}	break;
 		case 'g': {	// read all general purpose registers
 			char * dst = rep;
 			for (int i = 0; i < 35; i++)
 				dst += gdb_read_register(g, i, dst);
-			gdb_send_reply(g, rep);						
+			gdb_send_reply(g, rep);
 		}	break;
 		case 'p': {	// read register
 			unsigned int regi = 0;
 			sscanf(cmd, "%x", &regi);
 			gdb_read_register(g, regi, rep);
-			gdb_send_reply(g, rep);			
+			gdb_send_reply(g, rep);
 		}	break;
 		case 'P': {	// write register
 			unsigned int regi = 0;
@@ -190,7 +199,7 @@
 			sscanf(cmd, "%x", &regi);
 			read_hex_string(val, (uint8_t*)rep, strlen(val));
 			gdb_write_register(g, regi, (uint8_t*)rep);
-			gdb_send_reply(g, "OK");										
+			gdb_send_reply(g, "OK");
 		}	break;
 		case 'm': {	// read memory
 			uint32_t addr, len;
@@ -238,19 +247,19 @@
 			}
 			if (addr < 0xffff) {
 				read_hex_string(start + 1, avr->flash + addr, strlen(start+1));
-				gdb_send_reply(g, "OK");			
+				gdb_send_reply(g, "OK");
 			} else if (addr >= 0x800000 && (addr - 0x800000) <= avr->ramend) {
 				read_hex_string(start + 1, avr->data + addr - 0x800000, strlen(start+1));
-				gdb_send_reply(g, "OK");							
+				gdb_send_reply(g, "OK");
 			} else if (addr >= 0x810000 && (addr - 0x810000) <= avr->e2end) {
 				read_hex_string(start + 1, (uint8_t*)rep, strlen(start+1));
 				avr_eeprom_desc_t ee = {.offset = (addr - 0x810000), .size = len, .ee = (uint8_t*)rep };
 				avr_ioctl(avr, AVR_IOCTL_EEPROM_SET, &ee);
-				gdb_send_reply(g, "OK");							
+				gdb_send_reply(g, "OK");
 			} else {
 				printf("write memory error %08x, %08x\n", addr, len);
 				gdb_send_reply(g, "E01");
-			}		
+			}
 		}	break;
 		case 'c': {	// continue
 			avr->state = cpu_Running;
@@ -284,7 +293,7 @@
 				case 4: // access watchpoint
 				default:
 					gdb_send_reply(g, "");
-			}	
+			}
 		}	break;
 		default:
 			gdb_send_reply(g, "");
@@ -309,24 +318,26 @@
 
 	if (ret == 0)
 		return 0;
-	
+
 	if (FD_ISSET(g->listen, &read_set)) {
 		g->s = accept(g->listen, NULL, NULL);
 
 		if (g->s == -1) {
 			perror("gdb_network_handler accept");
+#ifndef __MINGW32__
 			sleep(5);
+#endif
 			return 1;
 		}
-        int i = 1;
-        setsockopt (g->s, IPPROTO_TCP, TCP_NODELAY, &i, sizeof (i));
+		char i = 1;
+		setsockopt (g->s, IPPROTO_TCP, TCP_NODELAY, &i, sizeof (i));
 		g->avr->state = cpu_Stopped;
-		printf("%s connection opened\n", __FUNCTION__);		
+		printf("%s connection opened\n", __FUNCTION__);
 	}
-		
+
 	if (g->s != -1 && FD_ISSET(g->s, &read_set)) {
-		uint8_t buffer[1024];
-		
+		char buffer[1024];
+
 		ssize_t r = recv(g->s, buffer, sizeof(buffer)-1, 0);
 
 		if (r == 0) {
@@ -339,14 +350,16 @@
 		}
 		if (r == -1) {
 			perror("gdb_network_handler recv");
+#ifndef __MINGW32__
 			sleep(1);
+#endif
 			return 1;
 		}
 		buffer[r] = 0;
 	//	printf("%s: received %d bytes\n'%s'\n", __FUNCTION__, r, buffer);
 	//	hdump("gdb", buffer, r);
 
-		uint8_t * src = buffer;
+		char * src = buffer;
 		while (*src == '+' || *src == '-')
 			src++;
 		// control C -- lets send the guy a nice status packet
@@ -357,7 +370,7 @@
 		}
 		if (*src  == '$') {
 			// strip checksum
-			uint8_t * end = buffer + r - 1;
+			char * end = buffer + r - 1;
 			while (end > src && *end != '#')
 				*end-- = 0;
 			*end = 0;
@@ -375,7 +388,7 @@
 int avr_gdb_processor(avr_t * avr, int sleep)
 {
 	if (!avr || !avr->gdb)
-		return 0;	
+		return 0;
 	avr_gdb_t * g = avr->gdb;
 
 	if (g->watchmap && avr->state == cpu_Running) {
@@ -384,7 +397,7 @@
 				DBG(printf("avr_gdb_processor hit breakpoint at %08x\n", avr->pc);)
 				gdb_send_quick_status(g, 0);
 				avr->state = cpu_Stopped;
-			}		
+			}
 	}
 	if (avr->state == cpu_StepDone) {
 		gdb_send_quick_status(g, 0);
@@ -407,7 +420,7 @@
 		return -1;
 	}
 
-	int i = 1;
+	char i = 1;
 	setsockopt(g->listen, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));
 
 	struct sockaddr_in address = { 0 };
@@ -429,6 +442,6 @@
 	// change default run behaviour to use the slightly slower versions
 	avr->run = avr_callback_run_gdb;
 	avr->sleep = avr_callback_sleep_gdb;
-	
+
 	return 0;
 }
diff -ur ../download/simavr/simavr/sim/sim_vcd_file.c simavr/simavr/sim/sim_vcd_file.c
--- ../download/simavr/simavr/sim/sim_vcd_file.c	2012-03-11 10:53:06 +1100
+++ simavr/simavr/sim/sim_vcd_file.c	2012-03-11 10:52:51 +1100
@@ -6,7 +6,7 @@
 
 	Copyright 2008, 2009 Michel Pollet <buserror@gmail.com>
 
- 	This file is part of simavr.
+	This file is part of simavr.
 
 	simavr is free software: you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -36,12 +36,12 @@
 	vcd->avr = avr;
 	strncpy(vcd->filename, filename, sizeof(vcd->filename));
 	vcd->period = avr_usec_to_cycles(vcd->avr, period);
-	
+
 	for (int i = 0; i < AVR_VCD_MAX_SIGNALS; i++) {
 		avr_init_irq(&avr->irq_pool, &vcd->signal[i].irq, i, 1, NULL /* TODO IRQ name */);
 		avr_irq_register_notify(&vcd->signal[i].irq, _avr_vcd_notify, vcd);
 	}
-	
+
 	return 0;
 }
 
@@ -69,10 +69,10 @@
 static char * _avr_vcd_get_signal_text(avr_vcd_signal_t * s, char * out, uint32_t value)
 {
 	char * dst = out;
-		
+
 	if (s->size > 1)
 		*dst++ = 'b';
-	
+
 	for (int i = s->size; i > 0; i--)
 		*dst++ = value & (1 << (i-1)) ? '1' : '0';
 	if (s->size > 1)
@@ -104,14 +104,18 @@
 		// if that trace was seen in this usec already, we fudge the base time
 		// to make sure the new value is offset by one usec, to make sure we get
 		// at least a small pulse on the waveform
-		// This is a bit of a fudge, but it is the only way to represent very 
+		// This is a bit of a fudge, but it is the only way to represent very
 		// short"pulses" that are still visible on the waveform.
 		if (base == oldbase && seen & (1 << l->signal->irq.irq))
 			base++;	// this forces a new timestamp
-			
+
 		if (base > oldbase || li == 0) {
 			seen = 0;
+#if __MINGW32__
+			fprintf(vcd->output, "#%I64u\n", base);
+#else
 			fprintf(vcd->output, "#%llu\n", (long long unsigned int)base);
+#endif
 			oldbase = base;
 		}
 		seen |= (1 << l->signal->irq.irq);	// mark this trace as seen for this timestamp
@@ -127,7 +131,7 @@
 	return when + vcd->period;
 }
 
-int avr_vcd_add_signal(avr_vcd_t * vcd, 
+int avr_vcd_add_signal(avr_vcd_t * vcd,
 	avr_irq_t * signal_irq,
 	int signal_bit_size,
 	const char * name )
@@ -152,7 +156,7 @@
 		perror(vcd->filename);
 		return -1;
 	}
-		
+
 	fprintf(vcd->output, "$timescale 1ns $end\n");	// 1ns base
 	fprintf(vcd->output, "$scope module logic $end\n");
 
@@ -163,7 +167,7 @@
 
 	fprintf(vcd->output, "$upscope $end\n");
 	fprintf(vcd->output, "$enddefinitions $end\n");
-	
+
 	fprintf(vcd->output, "$dumpvars\n");
 	for (int i = 0; i < vcd->signal_count; i++) {
 		avr_vcd_signal_t * s = &vcd->signal[i];
@@ -172,7 +176,7 @@
 	}
 	fprintf(vcd->output, "$end\n");
 	vcd->start = vcd->avr->cycle;
-	avr_cycle_timer_register(vcd->avr, vcd->period, _avr_vcd_timer, vcd);	
+	avr_cycle_timer_register(vcd->avr, vcd->period, _avr_vcd_timer, vcd);
 	return 0;
 }
 
@@ -181,7 +185,7 @@
 	avr_cycle_timer_cancel(vcd->avr, _avr_vcd_timer, vcd);
 
 	avr_vcd_flush_log(vcd);
-	
+
 	if (vcd->output)
 		fclose(vcd->output);
 	vcd->output = NULL;
Only in simavr/simavr: sim_core_config.h
Only in simavr/simavr: sim_core_decl.h
diff -ur ../download/simavr/tests/tests.c simavr/tests/tests.c
--- ../download/simavr/tests/tests.c	2012-03-11 10:53:06 +1100
+++ simavr/tests/tests.c	2012-03-11 10:52:51 +1100
@@ -23,8 +23,10 @@
 }
 
 void tests_success(void) {
+#ifndef __MINGW32__
 	if (orig_stderr)
 		stderr = orig_stderr;
+#endif
 	fprintf(stderr, "OK: %s\n", test_name);
 	finished = 1;
 }
@@ -87,7 +89,7 @@
 	// Interrupt servicing might change the PC too, during 'sleep'
 	if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
 		avr_service_interrupts(avr);
-	
+
 	// if we were stepping, use this state to inform remote gdb
 
 	return avr->state;
@@ -95,11 +97,13 @@
 
 avr_t *tests_init_avr(const char *elfname) {
 	tests_cycle_count = 0;
+#ifndef __MINGW32__
 	if (tests_disable_stdout) {
 		orig_stderr = stderr;
 		fclose(stdout);
 		stderr = stdout;
 	}
+#endif
 	elf_firmware_t fw;
 	if (elf_read_firmware(elfname, &fw))
 		fail("Failed to read ELF firmware \"%s\"", elfname);
@@ -135,7 +139,7 @@
 		return reason;
 	}
 	fail("Error in test case: Should never reach this.");
-	return 0;	
+	return 0;
 }
 
 int tests_init_and_run_test(const char *elfname, unsigned long run_usec) {
@@ -228,8 +232,10 @@
 }
 
 void _fail(const char *filename, int linenum, const char *fmt, ...) {
+#ifndef __MINGW32__
 	if (orig_stderr)
 		stderr = orig_stderr;
+#endif
 
 	if (filename)
 		fprintf(stderr, "%s:%d: ", filename, linenum);
