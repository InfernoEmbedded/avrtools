Common subdirectories: smatch.orig/.git and smatch/.git
Common subdirectories: smatch.orig/Documentation and smatch/Documentation
diff -u smatch.orig/check_db_info.c smatch/check_db_info.c
--- smatch.orig/check_db_info.c	2010-11-03 10:15:07 +1100
+++ smatch/check_db_info.c	2010-11-03 12:53:04 +1100
@@ -17,9 +17,17 @@
 	static char buff[256];
 
 	if (num < 0) {
+#ifdef __MINGW32__
+		snprintf(buff, 255, "(%I64d)", num);
+#else
 		snprintf(buff, 255, "(%lld)", num);
+#endif
 	} else {
+#ifdef __MINGW32__
+		snprintf(buff, 255, "%I64d", num);
+#else
 		snprintf(buff, 255, "%lld", num);
+#endif
 	}
 	buff[255] = '\0';
 	return buff;
@@ -58,7 +66,11 @@
 		return;
 	}
 	if (get_value(ret_value, &val)) {
+#ifdef __MINGW32__
+		sm_msg("info: return_value %I64d", val);
+#else
 		sm_msg("info: return_value %lld", val);
+#endif
 		return;
 	}
 	state = get_state_expr(SMATCH_EXTRA, ret_value);
diff -u smatch.orig/check_err_ptr_deref.c smatch/check_err_ptr_deref.c
--- smatch.orig/check_err_ptr_deref.c	2010-11-03 10:15:07 +1100
+++ smatch/check_err_ptr_deref.c	2010-11-03 12:53:53 +1100
@@ -132,9 +132,17 @@
 			max = tmp_max;
 	} END_FOR_EACH_PTR(tmp);
 	if (min < -4095)
+#ifdef __MINGW32__
+		sm_msg("error: %I64d too low for ERR_PTR", min);
+#else
 		sm_msg("error: %lld too low for ERR_PTR", min);
+#endif
 	if (max > 0)
+#ifdef __MINGW32__
+		sm_msg("error: passing non neg %I64d to ERR_PTR", max);
+#else
 		sm_msg("error: passing non neg %lld to ERR_PTR", max);
+#endif
 }
 
 static void match_ptr_err(const char *fn, struct expression *expr, void *unused)
diff -u smatch.orig/check_propagate.c smatch/check_propagate.c
--- smatch.orig/check_propagate.c	2010-11-03 10:15:07 +1100
+++ smatch/check_propagate.c	2010-11-03 13:06:20 +1100
@@ -56,7 +56,11 @@
 	if (get_implied_min(last_return, &lret))
 		return;
 	name = get_variable_from_expr(last_return, NULL);
+#ifdef __MINGW32__
+	sm_msg("info: why not propagate '%s' from %s() instead of %I64d?",
+#else
 	sm_msg("info: why not propagate '%s' from %s() instead of %lld?",
+#endif
 		name, get_fn_name(last_func), rval);
 	free_string(name);
 }
diff -u smatch.orig/check_signed.c smatch/check_signed.c
--- smatch.orig/check_signed.c	2010-11-03 10:15:07 +1100
+++ smatch/check_signed.c	2010-11-03 13:09:29 +1100
@@ -76,7 +76,11 @@
 	max = type_max(sym);
 	if (max < val) {
 		name = get_variable_from_expr_complex(expr->left, NULL);
+#ifdef __MINGW32__
+		sm_msg("warn: value %I64d can't fit into %I64d '%s'", val, max, name);
+#else
 		sm_msg("warn: value %lld can't fit into %lld '%s'", val, max, name);
+#endif
 		free_string(name);
 	}
 	min = type_min(sym);
@@ -89,9 +93,17 @@
 			return;
 		name = get_variable_from_expr_complex(expr->left, NULL);
 		if (min == 0)
+#ifdef __MINGW32__
+			sm_msg("warn: assigning %I64d to unsigned variable '%s'", val, name);
+#else
 			sm_msg("warn: assigning %lld to unsigned variable '%s'", val, name);
+#endif
 		else
+#ifdef __MINGW32__
+			sm_msg("warn: value %I64d can't fit into %I64d '%s'", val, min, name);
+#else
 			sm_msg("warn: value %lld can't fit into %lld '%s'", val, min, name);
+#endif
 		free_string(name);
 	}
 
@@ -164,7 +176,11 @@
 
 	if (expr->op == SPECIAL_EQUAL || expr->op == SPECIAL_NOTEQUAL) {
 		if (eqneq_max(var_type) < known || eqneq_min(var_type) > known)
+#ifdef __MINGW32__
+			sm_msg("error: %s is never equal to %I64d (wrong type %I64d - %I64d).",
+#else
 			sm_msg("error: %s is never equal to %lld (wrong type %lld - %lld).",
+#endif
 				name, known, eqneq_min(var_type), eqneq_max(var_type));
 		goto free;
 	}
@@ -175,7 +191,11 @@
 	if (max < known) {
 		const char *tf = get_tf(max, known, lr, expr->op);
 
+#ifdef __MINGW32__
+		sm_msg("warn: %I64d is more than %I64d (max '%s' can be) so this is always %s.",
+#else
 		sm_msg("warn: %lld is more than %lld (max '%s' can be) so this is always %s.",
+#endif
 			known, max, name, tf);
 	}
 
@@ -186,14 +206,22 @@
 	}
 
 	if (type_unsigned(var_type) && known_type && !type_unsigned(known_type) && known < 0) {
+#ifdef __MINGW32__
+		sm_msg("warn: unsigned '%s' is never less than zero (%I64d).", name, known);
+#else
 		sm_msg("warn: unsigned '%s' is never less than zero (%lld).", name, known);
+#endif
 		goto free;
 	}
 
 	if (min < 0 && min > known) {
 		const char *tf = get_tf(min, known, lr, expr->op);
 
+#ifdef __MINGW32__
+		sm_msg("warn: %I64d is less than %I64d (min '%s' can be) so this is always %s.",
+#else
 		sm_msg("warn: %lld is less than %lld (min '%s' can be) so this is always %s.",
+#endif
 			known, min, name, tf);
 	}
 free:
Common subdirectories: smatch.orig/compat and smatch/compat
diff -u smatch.orig/compile-i386.c smatch/compile-i386.c
--- smatch.orig/compile-i386.c	2010-11-03 10:15:07 +1100
+++ smatch/compile-i386.c	2010-11-03 12:24:49 +1100
@@ -435,7 +435,11 @@
 		strcpy(name, s->reg->name);
 		break;
 	case STOR_VALUE:
+#ifdef __MINGW32__
+		sprintf(name, "$%I64d", s->value);
+#else
 		sprintf(name, "$%Ld", s->value);
+#endif
 		break;
 	case STOR_LABEL:
 		sprintf(name, "%s.L%d", s->flags & STOR_LABEL_VAL ? "$" : "",
@@ -920,7 +924,11 @@
 
 	assert(type != NULL);
 
+#ifdef __MINGW32__
+	printf("\t.%s\t%I64d\n", type, ll);
+#else
 	printf("\t.%s\t%Ld\n", type, ll);
+#endif
 }
 
 static void emit_global_noinit(const char *name, unsigned long modifiers,
@@ -2223,7 +2231,11 @@
 		return new;
 	}
 	if (sym->ctype.modifiers & MOD_ADDRESSABLE) {
+#ifdef __MINGW32__
+		printf("\taddi.%d\t\tv%d,vFP,$%I64d\n", bits_in_pointer, new->pseudo, sym->value);
+#else
 		printf("\taddi.%d\t\tv%d,vFP,$%lld\n", bits_in_pointer, new->pseudo, sym->value);
+#endif
 		return new;
 	}
 	printf("\taddi.%d\t\tv%d,vFP,$offsetof(%s:%p)\n", bits_in_pointer, new->pseudo, show_ident(sym->ident), sym);
Common subdirectories: smatch.orig/cwchash and smatch/cwchash
diff -u smatch.orig/example.c smatch/example.c
--- smatch.orig/example.c	2010-11-03 10:15:07 +1100
+++ smatch/example.c	2010-11-03 12:27:26 +1100
@@ -187,7 +187,11 @@
 	case OP_REG:
 		return op->reg->name;
 	case OP_VAL:
+#ifdef __MINGW32__
+		sprintf(p, "$%I64d", op->value);
+#else
 		sprintf(p, "$%lld", op->value);
+#endif
 		break;
 	case OP_MEM:
 	case OP_ADDR:
@@ -597,7 +601,11 @@
 
 	switch (pseudo->type) {
 	case PSEUDO_VAL:
+#ifdef __MINGW32__
+		output_insn(state, "movl $%I64d,%s", pseudo->value, hardreg->name);
+#else
 		output_insn(state, "movl $%lld,%s", pseudo->value, hardreg->name);
+#endif
 		break;
 	case PSEUDO_SYM:
 		src = find_pseudo_storage(state, pseudo, NULL);
@@ -1050,7 +1058,11 @@
 		unsigned long long mask;
 		mask = ~(~0ULL << old);
 		mask &= ~(~0ULL << new);
+#ifdef __MINGW32__
+		output_insn(state, "andl.%d $%#I64x,%s", insn->size, mask, dst->name);
+#else
 		output_insn(state, "andl.%d $%#llx,%s", insn->size, mask, dst->name);
+#endif
 	}
 	add_pseudo_reg(state, insn->target, dst);
 }
diff -u smatch.orig/expand.c smatch/expand.c
--- smatch.orig/expand.c	2010-11-03 10:15:07 +1100
+++ smatch/expand.c	2010-11-03 12:04:04 +1100
@@ -109,7 +109,11 @@
 	// OK if the bits were (and still are) purely sign bits
 	if (value & dropped) {
 		if (!(value & oldsignmask) || !(value & signmask) || (value & dropped) != dropped)
+#ifdef __MINGW32__
+			warning(old->pos, "cast truncates bits from constant value (%I64x becomes %I64x)",
+#else
 			warning(old->pos, "cast truncates bits from constant value (%llx becomes %llx)",
+#endif
 				value & oldmask,
 				value & mask);
 	}
Common subdirectories: smatch.orig/gvpr and smatch/gvpr
diff -u smatch.orig/lib.c smatch/lib.c
--- smatch.orig/lib.c	2010-11-03 10:15:07 +1100
+++ smatch/lib.c	2010-11-03 10:43:17 +1100
@@ -85,10 +85,12 @@
 
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
-	static char buffer[512];
+#define BUF_SIZE 512
+	static char buffer[BUF_SIZE];
 	const char *name;
+#define REAL_FMT fmt
 
-	vsprintf(buffer, fmt, args);	
+	vsnprintf(buffer, BUF_SIZE, REAL_FMT, args);
 	name = stream_name(pos.stream);
 		
 	fprintf(stderr, "%s:%d:%d: %s%s\n",
diff -u smatch.orig/linearize.c smatch/linearize.c
--- smatch.orig/linearize.c	2010-11-03 10:15:07 +1100
+++ smatch/linearize.c	2010-11-03 12:04:56 +1100
@@ -121,7 +121,11 @@
 		if (expr) {
 			switch (expr->type) {
 			case EXPR_VALUE:
+#ifdef __MINGW32__
+				snprintf(buf, 64, "<symbol value: %I64d>", expr->value);
+#else
 				snprintf(buf, 64, "<symbol value: %lld>", expr->value);
+#endif
 				break;
 			case EXPR_STRING:
 				return show_string(expr->string);
@@ -139,9 +143,17 @@
 	case PSEUDO_VAL: {
 		long long value = pseudo->value;
 		if (value > 1000 || value < -1000)
+#ifdef __MINGW32__
+			snprintf(buf, 64, "$%#I64x", value);
+#else
 			snprintf(buf, 64, "$%#llx", value);
+#endif
 		else
+#ifdef __MINGW32__
+			snprintf(buf, 64, "$%I64d", value);
+#else
 			snprintf(buf, 64, "$%lld", value);
+#endif
 		break;
 	}
 	case PSEUDO_ARG:
@@ -336,10 +348,18 @@
 			
 		switch (expr->type) {
 		case EXPR_VALUE:
+#ifdef __MINGW32__
+			buf += sprintf(buf, "%I64d", expr->value);
+#else
 			buf += sprintf(buf, "%lld", expr->value);
+#endif
 			break;
 		case EXPR_FVALUE:
+#ifdef __MINGW32__
+			buf += sprintf(buf, "%f", (double)expr->fvalue);
+#else
 			buf += sprintf(buf, "%Lf", expr->fvalue);
+#endif
 			break;
 		case EXPR_STRING:
 			buf += sprintf(buf, "%.40s", show_string(expr->string));
@@ -463,7 +483,11 @@
 	}
 
 	if (buf >= buffer + sizeof(buffer))
+#ifdef __MINGW32__
+		die("instruction buffer overflowed %d\n", buf - buffer);
+#else
 		die("instruction buffer overflowed %td\n", buf - buffer);
+#endif
 	do { --buf; } while (*buf == ' ');
 	*++buf = 0;
 	return buffer;
diff -u smatch.orig/parse.c smatch/parse.c
--- smatch.orig/parse.c	2010-11-03 10:15:07 +1100
+++ smatch/parse.c	2010-11-03 10:48:50 +1100
@@ -1734,7 +1734,11 @@
 	bitfield->bit_size = width;
 
 	if (width < 0 || width > INT_MAX) {
+#ifdef __MINGW32__
+		sparse_error(token->pos, "invalid bitfield width, %I64d.", width);
+#else
 		sparse_error(token->pos, "invalid bitfield width, %lld.", width);
+#endif
 		width = -1;
 	} else if (*ctx->ident && width == 0) {
 		sparse_error(token->pos, "invalid named zero-width bitfield `%s'",
diff -u smatch.orig/pre-process.c smatch/pre-process.c
--- smatch.orig/pre-process.c	2010-11-03 10:15:07 +1100
+++ smatch/pre-process.c	2010-11-03 11:32:42 +1100
@@ -161,12 +161,19 @@
 	} else if (token->ident == &__DATE___ident) {
 		if (!t)
 			time(&t);
+#if __MINGW32__
+		strftime(buffer, 12, "%b %d %Y", localtime(&t));
+		if (buffer[5] == '0') {
+			buffer[5] = ' ';
+		}
+#else
 		strftime(buffer, 12, "%b %e %Y", localtime(&t));
+#endif
 		replace_with_string(token, buffer);
 	} else if (token->ident == &__TIME___ident) {
 		if (!t)
 			time(&t);
-		strftime(buffer, 9, "%T", localtime(&t));
+		strftime(buffer, 9, "%H:%M:%S", localtime(&t));
 		replace_with_string(token, buffer);
 	}
 	return 1;
diff -u smatch.orig/show-parse.c smatch/show-parse.c
--- smatch.orig/show-parse.c	2010-11-03 10:15:07 +1100
+++ smatch/show-parse.c	2010-11-03 12:03:24 +1100
@@ -325,7 +325,11 @@
 			append(name, " )");
 			was_ptr = 0;
 		}
+#ifdef __MINGW32__
+		append(name, "[%I64d]", get_expression_value(sym->array_size));
+#else
 		append(name, "[%lld]", get_expression_value(sym->array_size));
+#endif
 		break;
 
 	case SYM_RESTRICT:
@@ -475,10 +479,18 @@
 			printf("    default");
 		} else {
 			if (expr->type == EXPR_VALUE) {
+#ifdef __MINGW32__
+				printf("    case %I64d", expr->value);
+#else
 				printf("    case %lld", expr->value);
+#endif
 				if (to) {
 					if (to->type == EXPR_VALUE) {
+#ifdef __MINGW32__
+						printf(" .. %I64d", to->value);
+#else
 						printf(" .. %lld", to->value);
+#endif
 					} else {
 						printf(" .. what?");
 					}
@@ -884,7 +896,11 @@
 		return new;
 	}
 	if (sym->ctype.modifiers & MOD_ADDRESSABLE) {
+#ifdef __MINGW32__
+		printf("\taddi.%d\t\tv%d,vFP,$%I64d\n", bits_in_pointer, new, sym->value);
+#else
 		printf("\taddi.%d\t\tv%d,vFP,$%lld\n", bits_in_pointer, new, sym->value);
+#endif
 		return new;
 	}
 	printf("\taddi.%d\t\tv%d,vFP,$offsetof(%s:%p)\n", bits_in_pointer, new, show_ident(sym->ident), sym);
@@ -944,7 +960,12 @@
 	int new = new_pseudo();
 	unsigned long long value = expr->value;
 
+#ifdef __MINGW32__
+	printf("\tmovi.%d\t\tv%d,$%I64u\n", expr->ctype->bit_size, new, value);
+#else
 	printf("\tmovi.%d\t\tv%d,$%llu\n", expr->ctype->bit_size, new, value);
+#endif
+
 	return new;
 }
 
@@ -952,8 +973,11 @@
 {
 	int new = new_pseudo();
 	long double value = expr->fvalue;
-
+#ifdef __MINGW32__
+	printf("\tmovf.%d\t\tv%d,$%f\n", expr->ctype->bit_size, new, (double)value);
+#else
 	printf("\tmovf.%d\t\tv%d,$%Lf\n", expr->ctype->bit_size, new, value);
+#endif
 	return new;
 }
 
diff -u smatch.orig/smatch_helper.c smatch/smatch_helper.c
--- smatch.orig/smatch_helper.c	2010-11-03 10:15:07 +1100
+++ smatch/smatch_helper.c	2010-11-03 12:48:25 +1100
@@ -183,7 +183,11 @@
 		char tmp[25];
 
 		*complicated = 1;
+#ifdef __MINGW32__
+		snprintf(tmp, 25, "%I64d", expr->value);
+#else
 		snprintf(tmp, 25, "%lld", expr->value);
+#endif
 		append(buf, tmp, len);
 		return;
 	}
diff -u smatch.orig/sparse.c smatch/sparse.c
--- smatch.orig/sparse.c	2010-11-03 10:15:07 +1100
+++ smatch/sparse.c	2010-11-03 12:26:05 +1100
@@ -138,7 +138,11 @@
 	if (count->type == PSEUDO_VAL) {
 		long long val = count->value;
 		if (val <= 0 || val > 100000)
+#ifdef __MINGW32__
+			warning(insn->pos, "%s with byte count of %I64d",
+#else
 			warning(insn->pos, "%s with byte count of %lld",
+#endif
 				show_ident(insn->func->sym->ident), val);
 		return;
 	}
diff -u smatch.orig/tokenize.c smatch/tokenize.c
--- smatch.orig/tokenize.c	2010-11-03 10:15:07 +1100
+++ smatch/tokenize.c	2010-11-03 11:28:54 +1100
@@ -427,8 +427,12 @@
 	}
 
 	if (p == buffer_end) {
+#ifdef __MINGW32__
+		sparse_error(stream_pos(stream), "number token exceeds %d characters",
+#else
 		sparse_error(stream_pos(stream), "number token exceeds %td characters",
-		      buffer_end - buffer);
+#endif
+				buffer_end - buffer);
 		// Pretend we saw just "1".
 		buffer[0] = '1';
 		p = buffer + 1;
Common subdirectories: smatch.orig/validation and smatch/validation
--- smatch/check_overflow.c.orig	2011-11-05 11:04:25 +1100
+++ smatch/check_overflow.c	2011-11-05 11:04:28 +1100
@@ -19,10 +19,10 @@
 };
 
 /*
- * This check has two smatch IDs.  
- * my_used_id - keeps a record of array offsets that have been used.  
+ * This check has two smatch IDs.
+ * my_used_id - keeps a record of array offsets that have been used.
  *              If the code checks that they are within bounds later on,
- *              we complain about using an array offset before checking 
+ *              we complain about using an array offset before checking
  *              that it is within bounds.
  */
 static int my_used_id;
@@ -112,7 +112,7 @@
 
 		if (!option_spammy) {
 			struct smatch_state *state;
-			
+
 			state = get_state_expr(SMATCH_EXTRA, offset);
 			if (state && is_whole_range(state))
 				return;
@@ -124,7 +124,11 @@
 		 * literal array with 4 or less chars.
 		 */
 		if (name && strcmp(name, "__s1") && strcmp(name, "__s2")) {
-			sm_msg("%s: buffer overflow '%s' %d <= %lld", 
+#ifdef __MINGW32__
+			sm_msg("%s: buffer overflow '%s' %d <= %I64d",
+#else
+			sm_msg("%s: buffer overflow '%s' %d <= %lld",
+#endif
 				level, name, array_size, max);
 		}
 		free_string(name);
@@ -227,7 +231,11 @@
 	if (!get_implied_value(dest_size_expr, &limit_size))
 		return;
 	if (dest_size && dest_size < limit_size)
-		sm_msg("error: snprintf() is printing too much %lld vs %d", limit_size, dest_size);
+#ifdef __MINGW32__
+	sm_msg("error: snprintf() is printing too much %I64d vs %d", limit_size, dest_size);
+#else
+	sm_msg("error: snprintf() is printing too much %lld vs %d", limit_size, dest_size);
+#endif
 	format = get_variable_from_expr(format_string, NULL);
 	if (!format)
 		return;
@@ -236,8 +244,13 @@
 	data_name = get_variable_from_expr_complex(data, NULL);
 	data_size = get_array_size_bytes(data);
 	if (limit_size < data_size)
+#ifdef __MINGW32__
+		sm_msg("error: snprintf() chops off the last chars of '%s': %d vs %I64d",
+				data_name, data_size, limit_size);
+#else
 		sm_msg("error: snprintf() chops off the last chars of '%s': %d vs %lld",
-		       data_name, data_size, limit_size);
+				data_name, data_size, limit_size);
+#endif
 free:
 	free_string(data_name);
 	free_string(format);
@@ -295,7 +308,11 @@
 		return;
 
 	dest_name = get_variable_from_expr_complex(dest, NULL);
+#ifdef __MINGW32__
+	sm_msg("error: %s() '%s' too small (%d vs %I64d)", fn, dest_name, has, needed);
+#else
 	sm_msg("error: %s() '%s' too small (%d vs %lld)", fn, dest_name, has, needed);
+#endif
 	free_string(dest_name);
 }
 
--- smatch/smatch_ranges.c.orig	2011-11-05 10:54:14 +1100
+++ smatch/smatch_ranges.c	2011-11-05 11:13:14 +1100
@@ -26,9 +26,17 @@
 	} else if (num == whole_range.max) {
 		snprintf(buff, 255, "max");
 	} else if (num < 0) {
+#ifdef __MINGW32__
+		snprintf(buff, 255, "(%I64d)", num);
+#else
 		snprintf(buff, 255, "(%lld)", num);
+#endif
 	} else {
+#ifdef __MINGW32__
+		snprintf(buff, 255, "%I64d", num);
+#else
 		snprintf(buff, 255, "%lld", num);
+#endif
 	}
 	buff[255] = '\0';
 	return buff;
@@ -83,7 +91,11 @@
 	struct data_range *ret;
 
 	if (min > max) {
+#ifdef __MINGW32__
+		sm_msg("Error invalid range %I64d to %I64d", min, max);
+#else
 		sm_msg("Error invalid range %lld to %lld", min, max);
+#endif
 		min = whole_range.min;
 		max = whole_range.max;
 	}
@@ -104,7 +116,11 @@
 	struct data_range *ret;
 
 	if (min > max) {
+#ifdef __MINGW32__
+		sm_msg("Error invalid range %I64d to %I64d", min, max);
+#else
 		sm_msg("Error invalid range %lld to %lld", min, max);
+#endif
 		min = whole_range.min;
 		max = whole_range.max;
 	}
@@ -125,7 +141,7 @@
 	struct data_range *tmp = NULL;
 	struct data_range *new = NULL;
 	int check_next = 0;
-	
+
  	FOR_EACH_PTR(*list, tmp) {
 		if (check_next) {
 			/* Sometimes we overlap with more than one range
@@ -271,7 +287,7 @@
 	return drange->max;
 }
 
-/* 
+/*
  * if it can be only one and only value return 1, else return 0
  */
 int get_single_value_from_dinfo(struct data_info *dinfo, long long *val)
